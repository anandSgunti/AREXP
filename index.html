<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>WebAR 3D Touch Interaction</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background-color: #000;
            overflow: hidden;
            font-family: Arial, sans-serif;
            touch-action: none;
        }
        
        #container {
            position: relative;
            width: 100vw;
            height: 100vh;
        }
        
        #arCanvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }
        
        #ui {
            position: absolute;
            top: 20px;
            left: 20px;
            z-index: 1000;
            color: white;
            background: rgba(0, 0, 0, 0.7);
            padding: 15px;
            border-radius: 10px;
            font-size: 14px;
            max-width: 300px;
        }
        
        .button {
            background: #007AFF;
            color: white;
            border: none;
            padding: 12px 20px;
            border-radius: 8px;
            margin: 5px;
            cursor: pointer;
            font-size: 16px;
            touch-action: manipulation;
        }
        
        .button:hover {
            background: #0056CC;
        }
        
        .button:disabled {
            background: #666;
            cursor: not-allowed;
        }
        
        #status {
            margin-top: 10px;
            font-size: 12px;
            color: #ccc;
        }
        
        .controls {
            margin-top: 15px;
        }
        
        .control-group {
            margin-bottom: 10px;
        }
        
        .control-group label {
            display: block;
            margin-bottom: 5px;
            font-size: 12px;
        }
        
        .slider {
            width: 100%;
            margin: 5px 0;
        }
    </style>
</head>
<body>
    <div id="container">
        <canvas id="arCanvas"></canvas>
        <div id="ui">
            <div>
                <button id="startAR" class="button">Start AR Experience</button>
                <button id="resetObject" class="button">Reset Object</button>
            </div>
            <div id="status">Touch to interact with the 3D object</div>
            <div class="controls">
                <div class="control-group">
                    <label for="scaleSlider">Scale:</label>
                    <input type="range" id="scaleSlider" class="slider" min="0.1" max="5" step="0.1" value="1">
                </div>
                <div class="control-group">
                    <label for="rotationSpeed">Auto Rotation:</label>
                    <input type="range" id="rotationSpeed" class="slider" min="0" max="0.05" step="0.005" value="0">
                </div>
            </div>
        </div>
    </div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.158.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.158.0/examples/jsm/"
            }
        }
    </script>
    <script type="module">
        // Import Three.js modules
        import * as THREE from 'three';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
        import { DRACOLoader } from 'three/addons/loaders/DRACOLoader.js';

        class WebAR3DApp {
            constructor() {
                // HARDCODED GLB FILE PATH - Change this to your model path
                this.GLB_FILE_PATH = 'Heart.glb'; // <-- CHANGE THIS PATH
                
                this.scene = null;
                this.camera = null;
                this.renderer = null;
                this.arObject = null;
                this.isARActive = false;
                this.touchStartPos = { x: 0, y: 0 };
                this.objectRotation = { x: 0, y: 0 };
                this.objectPosition = { x: 0, y: 0, z: -2 };
                this.objectScale = 1;
                this.autoRotationSpeed = 0;
                this.glbModel = null;
                this.modelBoundingBox = null;
                
                this.colors = {
                    blue: 0x4A90E2,
                    red: 0xE74C3C,
                    green: 0x2ECC71,
                    yellow: 0xF1C40F,
                    purple: 0x9B59B6
                };
                
                this.init();
                this.setupEventListeners();
                
                // Automatically load the hardcoded GLB file
                setTimeout(() => {
                    this.loadGLBFromPath(this.GLB_FILE_PATH);
                }, 500); // Small delay to ensure everything is initialized
            }
            
            init() {
                // Initialize Three.js scene
                this.scene = new THREE.Scene();
                this.camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.1, 1000);
                this.renderer = new THREE.WebGLRenderer({ 
                    canvas: document.getElementById('arCanvas'),
                    antialias: true,
                    alpha: true 
                });
                
                this.renderer.setSize(window.innerWidth, window.innerHeight);
                this.renderer.setPixelRatio(window.devicePixelRatio);
                this.renderer.shadowMap.enabled = true;
                this.renderer.shadowMap.type = THREE.PCFSoftShadowMap;
                
                // Setup lighting
                this.setupLighting();
                
                // Initialize GLB loader
                this.initGLBLoader();
                
                // Create default 3D object (fallback)
                this.createDefaultObject();
                
                // Position camera
                this.camera.position.set(0, 0, 0);
                
                // Start render loop
                this.animate();
                
                // Apply initial settings
                this.objectScale = 1;
                this.autoRotationSpeed = 0;
                
                // Update UI with initial values
                document.getElementById('scaleSlider').value = this.objectScale;
                document.getElementById('rotationSpeed').value = this.autoRotationSpeed;
                
                this.updateStatus("Initializing - Loading GLB model...");
            }
            
            setupLighting() {
                // Ambient light
                const ambientLight = new THREE.AmbientLight(0x404040, 0.6);
                this.scene.add(ambientLight);
                
                // Directional light
                const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
                directionalLight.position.set(5, 10, 5);
                directionalLight.castShadow = true;
                directionalLight.shadow.mapSize.width = 2048;
                directionalLight.shadow.mapSize.height = 2048;
                this.scene.add(directionalLight);
                
                // Point light for better illumination
                const pointLight = new THREE.PointLight(0xffffff, 0.5, 100);
                pointLight.position.set(-10, 10, -10);
                this.scene.add(pointLight);
            }
            
            initGLBLoader() {
                // Initialize GLTF loader with imported modules
                this.gltfLoader = new GLTFLoader();
                
                // Optional: Setup Draco decoder for compressed models
                const dracoLoader = new DRACOLoader();
                dracoLoader.setDecoderPath('https://www.gstatic.com/draco/versioned/decoders/1.4.3/');
                this.gltfLoader.setDRACOLoader(dracoLoader);
                
                this.updateStatus("GLB loader initialized - Ready to load models");
            }
            
            // Load GLB from URL or file path
            loadGLBFromPath(path) {
                if (!path) {
                    this.updateStatus("No GLB path provided");
                    return;
                }
                
                this.updateStatus(`Loading GLB from: ${path}`);
                
                this.gltfLoader.load(
                    path,
                    (gltf) => {
                        this.onGLBLoaded(gltf);
                    },
                    (progress) => {
                        if (progress.total > 0) {
                            const percent = Math.round((progress.loaded / progress.total) * 100);
                            this.updateStatus(`Loading GLB: ${percent}%`);
                        } else {
                            this.updateStatus(`Loading GLB: ${Math.round(progress.loaded / 1024)}KB loaded`);
                        }
                    },
                    (error) => {
                        console.error('Error loading GLB file:', error);
                        this.updateStatus(`Error loading GLB: ${error.message || 'File not found or invalid format'}`);
                        // Show default object if GLB fails
                        this.updateStatus("GLB loading failed - showing default 3D object");
                    }
                );
            }
            
            loadGLBFile(file) {
                if (!file) return;
                
                this.updateStatus("Loading GLB file...");
                
                const reader = new FileReader();
                reader.onload = (event) => {
                    const arrayBuffer = event.target.result;
                    
                    this.gltfLoader.parse(arrayBuffer, '', (gltf) => {
                        this.onGLBLoaded(gltf);
                    }, (error) => {
                        console.error('Error loading GLB file:', error);
                        this.updateStatus("Error loading GLB file. Please check the file format.");
                    });
                };
                
                reader.onerror = () => {
                    this.updateStatus("Error reading file. Please try again.");
                };
                
                reader.readAsArrayBuffer(file);
            }
            
            onGLBLoaded(gltf) {
                // Remove existing model if any
                if (this.glbModel) {
                    this.scene.remove(this.glbModel);
                }
                
                // Remove default object if it exists
                if (this.arObject && !this.glbModel) {
                    this.scene.remove(this.arObject);
                }
                
                // Get the loaded model
                this.glbModel = gltf.scene;
                
                // Calculate bounding box for proper scaling and positioning
                this.modelBoundingBox = new THREE.Box3().setFromObject(this.glbModel);
                const size = this.modelBoundingBox.getSize(new THREE.Vector3());
                const center = this.modelBoundingBox.getCenter(new THREE.Vector3());
                
                // Center the model
                this.glbModel.position.sub(center);
                
                // Auto-scale model to fit in view (optional)
                const maxDimension = Math.max(size.x, size.y, size.z);
                if (maxDimension > 2) {
                    const scale = 2 / maxDimension;
                    this.glbModel.scale.multiplyScalar(scale);
                }
                
                // Position the model
                this.glbModel.position.set(
                    this.objectPosition.x,
                    this.objectPosition.y,
                    this.objectPosition.z
                );
                
                // Enable shadows for all meshes in the model
                this.glbModel.traverse((child) => {
                    if (child.isMesh) {
                        child.castShadow = true;
                        child.receiveShadow = true;
                        
                        // Ensure materials have proper lighting
                        if (child.material) {
                            child.material.needsUpdate = true;
                        }
                    }
                });
                
                // Add model to scene
                this.scene.add(this.glbModel);
                
                // Update reference for interactions
                this.arObject = this.glbModel;
                
                this.updateStatus(`GLB model loaded successfully! Size: ${size.x.toFixed(2)} x ${size.y.toFixed(2)} x ${size.z.toFixed(2)}`);
                
                // Play animations if any
                if (gltf.animations && gltf.animations.length > 0) {
                    this.mixer = new THREE.AnimationMixer(this.glbModel);
                    gltf.animations.forEach((clip) => {
                        const action = this.mixer.clipAction(clip);
                        action.play();
                    });
                    this.updateStatus("GLB model loaded with animations!");
                }
            }
            
            createDefaultObject() {
                // Create a compound 3D object (cube with sphere on top)
                const group = new THREE.Group();
                
                // Base cube
                const cubeGeometry = new THREE.BoxGeometry(0.5, 0.5, 0.5);
                const cubeMaterial = new THREE.MeshPhongMaterial({ 
                    color: this.colors.blue,
                    shininess: 100
                });
                const cube = new THREE.Mesh(cubeGeometry, cubeMaterial);
                cube.position.y = -0.25;
                cube.castShadow = true;
                cube.receiveShadow = true;
                group.add(cube);
                
                // Top sphere
                const sphereGeometry = new THREE.SphereGeometry(0.2, 32, 32);
                const sphereMaterial = new THREE.MeshPhongMaterial({ 
                    color: this.colors.blue,
                    shininess: 100
                });
                const sphere = new THREE.Mesh(sphereGeometry, sphereMaterial);
                sphere.position.y = 0.2;
                sphere.castShadow = true;
                group.add(sphere);
                
                // Add some decorative elements
                const torusGeometry = new THREE.TorusGeometry(0.3, 0.05, 16, 100);
                const torusMaterial = new THREE.MeshPhongMaterial({ 
                    color: this.colors.blue,
                    shininess: 100
                });
                const torus = new THREE.Mesh(torusGeometry, torusMaterial);
                torus.rotation.x = Math.PI / 2;
                torus.castShadow = true;
                group.add(torus);
                
                // Position the object
                group.position.set(this.objectPosition.x, this.objectPosition.y, this.objectPosition.z);
                group.scale.set(this.objectScale, this.objectScale, this.objectScale);
                
                this.arObject = group;
                this.scene.add(group);
            }
            
            setupEventListeners() {
                const startARBtn = document.getElementById('startAR');
                const resetBtn = document.getElementById('resetObject');
                const scaleSlider = document.getElementById('scaleSlider');
                const rotationSpeedSlider = document.getElementById('rotationSpeed');
                const canvas = document.getElementById('arCanvas');
                
                // AR controls
                startARBtn.addEventListener('click', () => this.startAR());
                resetBtn.addEventListener('click', () => this.resetObject());
                
                // Object controls
                scaleSlider.addEventListener('input', (e) => this.updateScale(e.target.value));
                rotationSpeedSlider.addEventListener('input', (e) => this.updateRotationSpeed(e.target.value));
                
                // Touch events for iPad
                canvas.addEventListener('touchstart', (e) => this.onTouchStart(e), { passive: false });
                canvas.addEventListener('touchmove', (e) => this.onTouchMove(e), { passive: false });
                canvas.addEventListener('touchend', (e) => this.onTouchEnd(e), { passive: false });
                
                // Mouse events for desktop testing
                canvas.addEventListener('mousedown', (e) => this.onMouseDown(e));
                canvas.addEventListener('mousemove', (e) => this.onMouseMove(e));
                canvas.addEventListener('mouseup', (e) => this.onMouseUp(e));
                
                // Handle orientation changes
                window.addEventListener('orientationchange', () => {
                    setTimeout(() => this.onWindowResize(), 100);
                });
                
                window.addEventListener('resize', () => this.onWindowResize());
            }
            
            async startAR() {
                try {
                    // Check for WebXR support
                    if ('xr' in navigator) {
                        const isSupported = await navigator.xr.isSessionSupported('immersive-ar');
                        if (isSupported) {
                            this.startWebXR();
                            return;
                        }
                    }
                    
                    // Fallback to camera-based AR simulation
                    this.startCameraAR();
                } catch (error) {
                    console.error('AR initialization failed:', error);
                    this.updateStatus('AR not supported - using 3D view mode');
                    this.isARActive = true;
                    document.getElementById('startAR').textContent = 'AR Active (3D Mode)';
                }
            }
            
            async startWebXR() {
                try {
                    const session = await navigator.xr.requestSession('immersive-ar');
                    this.renderer.xr.setSession(session);
                    this.isARActive = true;
                    this.updateStatus('WebXR AR Session Active');
                    document.getElementById('startAR').textContent = 'Stop AR';
                } catch (error) {
                    console.error('WebXR failed:', error);
                    this.startCameraAR();
                }
            }
            
            async startCameraAR() {
                try {
                    const stream = await navigator.mediaDevices.getUserMedia({
                        video: { 
                            facingMode: 'environment',
                            width: { ideal: 1280 },
                            height: { ideal: 720 }
                        }
                    });
                    
                    // Create video element for background
                    const video = document.createElement('video');
                    video.srcObject = stream;
                    video.play();
                    
                    video.addEventListener('loadedmetadata', () => {
                        const videoTexture = new THREE.VideoTexture(video);
                        this.scene.background = videoTexture;
                        this.isARActive = true;
                        this.updateStatus('Camera AR Active - Touch to interact');
                        document.getElementById('startAR').textContent = 'Stop AR';
                    });
                } catch (error) {
                    console.error('Camera access failed:', error);
                    this.updateStatus('Camera unavailable - 3D view mode');
                    this.isARActive = true;
                    document.getElementById('startAR').textContent = 'AR Active (3D Mode)';
                }
            }
            
            onTouchStart(event) {
                event.preventDefault();
                if (event.touches.length === 1) {
                    const touch = event.touches[0];
                    this.touchStartPos.x = touch.clientX;
                    this.touchStartPos.y = touch.clientY;
                    this.updateStatus('Touch detected - Rotate object');
                }
            }
            
            onTouchMove(event) {
                event.preventDefault();
                if (event.touches.length === 1 && this.arObject) {
                    const touch = event.touches[0];
                    const deltaX = touch.clientX - this.touchStartPos.x;
                    const deltaY = touch.clientY - this.touchStartPos.y;
                    
                    // Rotate object based on touch movement
                    this.objectRotation.y += deltaX * 0.01;
                    this.objectRotation.x += deltaY * 0.01;
                    
                    this.arObject.rotation.x = this.objectRotation.x;
                    this.arObject.rotation.y = this.objectRotation.y;
                    
                    this.touchStartPos.x = touch.clientX;
                    this.touchStartPos.y = touch.clientY;
                }
            }
            
            onTouchEnd(event) {
                event.preventDefault();
                this.updateStatus('Touch ended - Object rotated');
            }
            
            // Mouse events for desktop testing
            onMouseDown(event) {
                this.touchStartPos.x = event.clientX;
                this.touchStartPos.y = event.clientY;
                this.isMouseDown = true;
            }
            
            onMouseMove(event) {
                if (this.isMouseDown && this.arObject) {
                    const deltaX = event.clientX - this.touchStartPos.x;
                    const deltaY = event.clientY - this.touchStartPos.y;
                    
                    this.objectRotation.y += deltaX * 0.01;
                    this.objectRotation.x += deltaY * 0.01;
                    
                    this.arObject.rotation.x = this.objectRotation.x;
                    this.arObject.rotation.y = this.objectRotation.y;
                    
                    this.touchStartPos.x = event.clientX;
                    this.touchStartPos.y = event.clientY;
                }
            }
            
            onMouseUp(event) {
                this.isMouseDown = false;
            }
            
            updateScale(value) {
                this.objectScale = parseFloat(value);
                if (this.arObject) {
                    this.arObject.scale.set(this.objectScale, this.objectScale, this.objectScale);
                }
                this.updateStatus(`Scale updated to ${this.objectScale}`);
            }
            
            updateRotationSpeed(value) {
                this.autoRotationSpeed = parseFloat(value);
                this.updateStatus(`Auto rotation speed: ${this.autoRotationSpeed}`);
            }
            
            updateColor(colorName) {
                // This function is kept for compatibility but works mainly on default objects
                if (this.arObject && this.colors[colorName] && !this.glbModel) {
                    const color = this.colors[colorName];
                    this.arObject.children.forEach(child => {
                        if (child.material) {
                            child.material.color.setHex(color);
                        }
                    });
                    this.updateStatus(`Color changed to ${colorName}`);
                }
            }
            
            resetObject() {
                if (this.arObject) {
                    this.objectRotation = { x: 0, y: 0 };
                    this.objectPosition = { x: 0, y: 0, z: -2 };
                    this.objectScale = 1;
                    this.autoRotationSpeed = 0;
                    
                    this.arObject.rotation.set(0, 0, 0);
                    this.arObject.position.set(0, 0, -2);
                    this.arObject.scale.set(1, 1, 1);
                    
                    document.getElementById('scaleSlider').value = 1;
                    document.getElementById('rotationSpeed').value = 0;
                    
                    this.updateStatus('Object reset to default state');
                }
            }
            
            onWindowResize() {
                this.camera.aspect = window.innerWidth / window.innerHeight;
                this.camera.updateProjectionMatrix();
                this.renderer.setSize(window.innerWidth, window.innerHeight);
            }
            
            updateStatus(message) {
                document.getElementById('status').textContent = message;
            }
            
            animate() {
                requestAnimationFrame(() => this.animate());
                
                // Update animation mixer if GLB has animations
                if (this.mixer) {
                    this.mixer.update(0.016); // Assuming 60fps
                }
                
                // Auto rotation
                if (this.arObject && this.autoRotationSpeed > 0) {
                    this.arObject.rotation.y += this.autoRotationSpeed;
                }
                
                // Add subtle animation to default object only
                if (this.arObject && !this.glbModel) {
                    this.arObject.children[1].rotation.y += 0.01; // Rotate the sphere
                    this.arObject.children[2].rotation.z += 0.02; // Rotate the torus
                }
                
                this.renderer.render(this.scene, this.camera);
            }
        }
        
        // Initialize the app when DOM is loaded
        document.addEventListener('DOMContentLoaded', () => {
            new WebAR3DApp();
        });
        
        // Prevent default touch behaviors
        document.addEventListener('touchstart', function(e) {
            if (e.target.tagName !== 'INPUT' && e.target.tagName !== 'SELECT' && e.target.tagName !== 'BUTTON') {
                e.preventDefault();
            }
        }, { passive: false });
        
        document.addEventListener('touchmove', function(e) {
            e.preventDefault();
        }, { passive: false });
    </script>
</body>
</html>
