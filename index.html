<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <title>AR GLTF Viewer (iOS Safari iPad)</title>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      overflow: hidden;
      width: 100%;
      height: 100%;
      background-color: #111;
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
    }
    
    canvas {
      display: block;
      width: 100vw;
      height: 100vh;
    }
    
    #ui {
      position: absolute;
      top: 20px;
      left: 20px;
      z-index: 100;
      display: flex;
      flex-direction: column;
      gap: 10px;
    }
    
    .button {
      background: rgba(0, 0, 0, 0.8);
      color: white;
      border: 2px solid #007AFF;
      border-radius: 8px;
      padding: 12px 20px;
      font-size: 16px;
      cursor: pointer;
      transition: all 0.3s ease;
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
    }
    
    .button:hover {
      background: rgba(0, 122, 255, 0.2);
      transform: scale(1.05);
    }
    
    .button:disabled {
      background: rgba(128, 128, 128, 0.5);
      color: #888;
      border-color: #666;
      cursor: not-allowed;
      transform: none;
    }
    
    #status {
      background: rgba(0, 0, 0, 0.8);
      color: white;
      padding: 8px 16px;
      border-radius: 6px;
      font-size: 14px;
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
    }
    
    #instructions {
      position: absolute;
      bottom: 20px;
      left: 20px;
      right: 20px;
      background: rgba(0, 0, 0, 0.8);
      color: white;
      padding: 16px;
      border-radius: 8px;
      font-size: 14px;
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
      display: none;
    }
    
    .ar-instructions {
      display: block !important;
    }
  </style>
</head>
<body>
  <canvas id="viewer"></canvas>
  
  <div id="ui">
    <button id="arButton" class="button" disabled>Checking AR...</button>
    <button id="debugButton" class="button">Debug Info</button>
    <div id="status">Loading...</div>
    <div id="debug" style="display: none; font-size: 12px; max-width: 300px; word-wrap: break-word;"></div>
  </div>
  
  <div id="instructions">
    <strong>AR Mode Active</strong><br>
    • Move your device to scan the environment<br>
    • Tap to place the 3D model<br>
    • Pinch to scale, drag to move<br>
    • Tap "Exit AR" to return to 3D view
  </div>

  <!-- Import Maps for Module Resolution -->
  <script type="importmap">
    {
      "imports": {
        "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
        "three/examples/jsm/": "https://unpkg.com/three@0.160.0/examples/jsm/"
      }
    }
  </script>
  
  <script type="module">
    import * as THREE from 'three';
    import { GLTFLoader } from 'three/examples/jsm/loaders/GLTFLoader.js';
    import { OrbitControls } from 'three/examples/jsm/controls/OrbitControls.js';
    import { ARButton } from 'three/examples/jsm/webxr/ARButton.js';

    // Global variables
    let scene, camera, renderer, controls;
    let model, mixer;
    let isARMode = false;
    let hitTestSource = null;
    let hitTestSourceRequested = false;
    let reticle;
    let modelPlaced = false;
    
    // UI elements
    const arButton = document.getElementById('arButton');
    const debugButton = document.getElementById('debugButton');
    const status = document.getElementById('status');
    const debug = document.getElementById('debug');
    const instructions = document.getElementById('instructions');

    // Initialize the application
    init();

    function init() {
      // Create scene
      scene = new THREE.Scene();

      // Create camera
      camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 100);
      camera.position.set(0, 1, 4);

      // Create renderer with WebXR support
      renderer = new THREE.WebGLRenderer({
        canvas: document.getElementById('viewer'),
        antialias: true,
        alpha: true
      });
      renderer.setClearColor(0x111111);
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setPixelRatio(window.devicePixelRatio);
      renderer.xr.enabled = true;
      renderer.shadowMap.enabled = true;
      renderer.shadowMap.type = THREE.PCFSoftShadowMap;

      // Create controls for non-AR mode
      controls = new OrbitControls(camera, renderer.domElement);
      controls.target.set(0, 0, 0);
      controls.update();

      // Setup lighting
      setupLighting();

      // Create reticle for AR mode
      createReticle();

      // Check WebXR support
      checkARSupport();

      // Load GLTF model
      loadModel();

      // Setup event listeners
      setupEventListeners();

      // Start render loop
      animate();
    }

    function setupLighting() {
      // Directional light
      const dirLight = new THREE.DirectionalLight(0xffffff, 1.2);
      dirLight.position.set(5, 10, 5);
      dirLight.castShadow = true;
      dirLight.shadow.mapSize.width = 2048;
      dirLight.shadow.mapSize.height = 2048;
      scene.add(dirLight);

      // Point light
      const pointLight = new THREE.PointLight(0xffffff, 0.6, 20);
      pointLight.position.set(-3, 3, 3);
      scene.add(pointLight);

      // Ambient light
      const ambientLight = new THREE.AmbientLight(0x404040, 0.4);
      scene.add(ambientLight);
    }

    function createReticle() {
      const geometry = new THREE.RingGeometry(0.15, 0.2, 32).rotateX(-Math.PI / 2);
      const material = new THREE.MeshBasicMaterial({ color: 0x007AFF });
      reticle = new THREE.Mesh(geometry, material);
      reticle.matrixAutoUpdate = false;
      reticle.visible = false;
      scene.add(reticle);
    }

    async function checkARSupport() {
      console.log('Checking AR support...');
      
      // First check if we're on iOS Safari
      const isIOSSafari = /iPad|iPhone|iPod/.test(navigator.userAgent) && /Safari/.test(navigator.userAgent);
      console.log('iOS Safari detected:', isIOSSafari);
      
      if ('xr' in navigator) {
        console.log('WebXR available');
        try {
          // Check for immersive-ar support
          const isSupported = await navigator.xr.isSessionSupported('immersive-ar');
          console.log('AR session supported:', isSupported);
          
          if (isSupported) {
            arButton.disabled = false;
            arButton.textContent = 'Start AR';
            status.textContent = 'AR Ready';
          } else {
            // Try fallback - enable button anyway for testing
            arButton.disabled = false;
            arButton.textContent = 'Try AR';
            status.textContent = 'AR support uncertain - try anyway';
          }
        } catch (error) {
          console.error('WebXR support check failed:', error);
          // Enable button for manual testing
          arButton.disabled = false;
          arButton.textContent = 'Try AR';
          status.textContent = 'AR check failed - manual test';
        }
      } else {
        console.log('WebXR not available');
        // For iOS Safari, enable button anyway as WebXR might still work
        if (isIOSSafari) {
          arButton.disabled = false;
          arButton.textContent = 'Try AR';
          status.textContent = 'WebXR detection failed - try anyway';
        } else {
          status.textContent = 'WebXR not available';
        }
      }
    }

    function loadModel() {
      const loader = new GLTFLoader();
      
      loader.load(
        'gltf/yourmodel.gltf', // ← Set your correct path here
        (gltf) => {
          model = gltf.scene;
          
          // Center model
          const box = new THREE.Box3().setFromObject(model);
          const center = box.getCenter(new THREE.Vector3());
          model.position.sub(center);
          
          // Scale the model
          model.scale.set(0.5, 0.5, 0.5); // Smaller scale for AR
          
          // Improve texture quality
          model.traverse(child => {
            if (child.isMesh) {
              child.castShadow = true;
              child.receiveShadow = true;
              
              if (child.material) {
                const mtl = child.material;
                ['map', 'normalMap', 'roughnessMap', 'metalnessMap'].forEach(mapType => {
                  if (mtl[mapType]) {
                    mtl[mapType].anisotropy = renderer.capabilities.getMaxAnisotropy();
                    mtl[mapType].minFilter = THREE.LinearMipMapLinearFilter;
                    mtl[mapType].magFilter = THREE.LinearFilter;
                    mtl[mapType].needsUpdate = true;
                  }
                });
              }
            }
          });

          // Setup animations if available
          if (gltf.animations && gltf.animations.length > 0) {
            mixer = new THREE.AnimationMixer(model);
            gltf.animations.forEach(clip => {
              mixer.clipAction(clip).play();
            });
          }

          // Add to scene for normal viewing
          scene.add(model);
          status.textContent = 'Model loaded - AR Ready';
        },
        (xhr) => {
          const progress = (xhr.loaded / xhr.total * 100).toFixed(1);
          status.textContent = `Loading: ${progress}%`;
        },
        (error) => {
          console.error('GLTF Load Error:', error);
          status.textContent = 'Model load failed';
        }
      );
    }

    function setupEventListeners() {
      // AR button click
      arButton.addEventListener('click', toggleAR);
      
      // Debug button click
      debugButton.addEventListener('click', toggleDebug);

      // Window resize
      window.addEventListener('resize', onWindowResize);

      // Touch events for AR interaction
      renderer.domElement.addEventListener('touchstart', onTouchStart, { passive: false });
    }
    
    function toggleDebug() {
      const isVisible = debug.style.display !== 'none';
      debug.style.display = isVisible ? 'none' : 'block';
      
      if (!isVisible) {
        updateDebugInfo();
      }
    }
    
    function updateDebugInfo() {
      const userAgent = navigator.userAgent;
      const isIOSSafari = /iPad|iPhone|iPod/.test(userAgent) && /Safari/.test(userAgent);
      const hasWebXR = 'xr' in navigator;
      
      debug.innerHTML = `
        <strong>Debug Info:</strong><br>
        iOS Safari: ${isIOSSafari}<br>
        WebXR Available: ${hasWebXR}<br>
        User Agent: ${userAgent}<br>
        Location: ${window.location.href}<br>
        HTTPS: ${window.location.protocol === 'https:'}<br>
        Three.js Version: ${THREE.REVISION}
      `;
    }

    async function toggleAR() {
      console.log('Toggle AR clicked, isARMode:', isARMode);
      
      if (!isARMode) {
        try {
          console.log('Attempting to start AR session...');
          
          // Try different session configurations
          const sessionOptions = [
            {
              requiredFeatures: ['hit-test'],
              optionalFeatures: ['dom-overlay'],
              domOverlay: { root: document.body }
            },
            {
              requiredFeatures: ['hit-test']
            },
            {
              optionalFeatures: ['hit-test']
            },
            {} // Minimal config
          ];
          
          let session = null;
          
          for (let i = 0; i < sessionOptions.length; i++) {
            try {
              console.log(`Trying session config ${i + 1}:`, sessionOptions[i]);
              session = await navigator.xr.requestSession('immersive-ar', sessionOptions[i]);
              console.log('AR session created successfully with config', i + 1);
              break;
            } catch (configError) {
              console.log(`Config ${i + 1} failed:`, configError);
              if (i === sessionOptions.length - 1) {
                throw configError;
              }
            }
          }
          
          if (session) {
            await renderer.xr.setSession(session);
            isARMode = true;
            arButton.textContent = 'Exit AR';
            instructions.classList.add('ar-instructions');
            status.textContent = 'AR Mode Active';
            
            // Hide model initially in AR mode
            if (model) {
              model.visible = false;
            }
            
            // Disable orbit controls in AR
            controls.enabled = false;
            
            console.log('AR session started successfully');
          }
          
        } catch (error) {
          console.error('Failed to start AR session:', error);
          status.textContent = `AR failed: ${error.message}`;
          
          // Show detailed error info
          if (error.name === 'NotSupportedError') {
            status.textContent = 'AR not supported on this device';
          } else if (error.name === 'NotAllowedError') {
            status.textContent = 'AR permission denied';
          } else if (error.name === 'SecurityError') {
            status.textContent = 'AR requires HTTPS';
          } else {
            status.textContent = `AR error: ${error.name}`;
          }
        }
      } else {
        console.log('Ending AR session...');
        const session = renderer.xr.getSession();
        if (session) {
          session.end();
        }
      }
    }

    function onWindowResize() {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    }

    function onTouchStart(event) {
      if (isARMode && reticle.visible && model) {
        event.preventDefault();
        
        // Place or move model
        model.position.copy(reticle.position);
        model.visible = true;
        modelPlaced = true;
        
        // Add some visual feedback
        model.scale.set(0.1, 0.1, 0.1);
        
        // Animate scale up
        const targetScale = 0.5;
        const animateScale = () => {
          if (model.scale.x < targetScale) {
            model.scale.addScalar(0.02);
            requestAnimationFrame(animateScale);
          }
        };
        animateScale();
      }
    }

    function animate() {
      renderer.setAnimationLoop(render);
    }

    function render(timestamp, frame) {
      if (mixer) {
        mixer.update(0.016); // Assuming 60fps
      }

      if (frame && isARMode) {
        const session = renderer.xr.getSession();
        
        if (hitTestSourceRequested === false) {
          session.requestReferenceSpace('viewer').then(referenceSpace => {
            session.requestHitTestSource({ space: referenceSpace }).then(source => {
              hitTestSource = source;
            });
          });
          hitTestSourceRequested = true;
        }

        if (hitTestSource) {
          const hitTestResults = frame.getHitTestResults(hitTestSource);
          
          if (hitTestResults.length > 0) {
            const hit = hitTestResults[0];
            reticle.visible = true;
            reticle.matrix.fromArray(hit.getPose(renderer.xr.getReferenceSpace()).transform.matrix);
          } else {
            reticle.visible = false;
          }
        }
      }

      renderer.render(scene, camera);
    }

    // Handle AR session end
    renderer.xr.addEventListener('sessionstart', () => {
      console.log('AR session started');
    });

    renderer.xr.addEventListener('sessionend', () => {
      console.log('AR session ended');
      isARMode = false;
      arButton.textContent = 'Start AR';
      instructions.classList.remove('ar-instructions');
      status.textContent = 'AR Ready';
      
      // Re-enable orbit controls
      controls.enabled = true;
      
      // Show model in normal mode
      if (model) {
        model.visible = true;
        model.position.set(0, 0, 0);
        model.scale.set(0.5, 0.5, 0.5);
      }
      
      // Reset hit test
      hitTestSourceRequested = false;
      hitTestSource = null;
      modelPlaced = false;
    });
  </script>
</body>
</html>
